SOLUZIONI:

0 	capire a cosa potrebbero servirci le funzioni date dal subject.


1 	creare i vari comandi es 

	"cd"     # Cambia la directory corrente
	"ls"     # Elenca i file e le directory nella directory corrente
	"pwd"    # Mostra la directory corrente
	"grep"   # Cerca all'interno dei file
	"echo"   # Visualizza un messaggio o una variabile
	"mkdir"  # Crea una nuova directory
	"rmdir"  # Rimuove una directory vuota
	"rm"     # Rimuove file o directory
	"mv"     # Sposta o rinomina file e directory
	"cp"     # Copia file e directory
	"chmod"  # Cambia i permessi di un file o una directory
	"chown"  # Cambia il proprietario di un file o una directory
	"ps"     # Mostra i processi in esecuzione
	"kill"   # Termina un processo
	"man"    # Mostra il manuale per un comando
	"exit"   # Esce dalla shell o termina la sessione corrente
	"clear"  # Pulisce la schermata della shell
	"history" # Elenca i comandi recenti eseguiti nella shell
	"find"   # Cerca file e directory basandosi su vari criteri
	"cat"    # Visualizza o concatena il contenuto dei file
	"less"   # Visualizza il contenuto dei file una pagina alla volta
	"tail"   # Mostra le ultime righe di un file
	"head"   # Mostra le prime righe di un file
	"which"  # Mostra il percorso del comando specificato
	"date"   # Mostra la data e l'ora correnti
	"df"     # Mostra l'utilizzo del disco
	"du"     # Mostra l'utilizzo dello spazio da parte dei file/directory
	"ifconfig" # Mostra le informazioni di configurazione della rete (sostituito da "ip" in molte distribuzioni moderne)
	"ping"   # Testa la connettività di rete
	"nano"   # Un semplice editor di testo in modalità testuale
	"top"    # Mostra le statistiche dei processi in tempo reale

 	etc... in quanto verranno sicuramente eseguiti nello stesso modo in ogni caso se richiamati.


2 	parsing e creare priorita` e accettazione ad esempio

 	~           && || | ; & << < >> > e anche ""           ~ 

	quindi richiamando uno dei "vari comandi" per poi passare l'output al successivo.


3	valgrind memoria, check e controllo codice/refactor
	END




Funzioni

printf 
malloc
free
write 
access
open
read 
close
fork
wait
waitpid
signal
sigaction
kill
exit


perror stampa automaticamente un messaggio d'errore correlato 
all'ultima operazione che ha avuto un errore e un messaggio personalizzato.

chdir riproduce cd è controllabile, se ritorna 0 significa che FUNZIONA

readline STAMPA e cattura un INPUT;

add_history AGGIUNGE STORICO (quello che volevamo risolvere con la structure che quindi non serve),

getcwd esegue "PWD" circa e lo salva in una STRINGA!

rl_clear_history PULISCE la HISTORY quella che volevamo mettere in struct (Non so se ci serve);


TO LEARN

rl_on_new_line
rl_replace_line
rl_redisplay
wait3
wait4
sigemptyset
sigaddset
stat
lstat
fstat
unlink
execve
up
dup2
pipe
opendir
readdir
closedir
strerror
isatty
ttyname
ttyslot
ioctl,
getenv
tcsetattr
tcgetattr
tgetent
tgetflag
tgetnum
tgetstr
tgoto
tputs
