{
    "sourceFile": "minishell.c",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1700408808921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1700408808921,
            "name": "Commit-0",
            "content": "/******************************************************************************/\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   minishell.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: shhuang <dsheng1993@gmail.com>             +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/09/27 18:14:43 by shhuang           #+#    #+#             */\n/*   Updated: 2023/11/19 16:46:48 by shhuang          ###   ########.fr       */\n/*                                                                            */\n/******************************************************************************/\n\n\n// IMPLEMENTARE: strcmp, strncmp\n#include \"minishell.h\"\n#include \"pipeline.h\"\n#include \"short_code.h\"\n\nvoid\tupdate_exit_status(t_var *exit_status, int new_val);\n\nint clear()\n{\n\t// write(STDOUT_FILENO, \"\\033[H\\033[2J\\033[3J\", 11);\n\t// write(STDOUT_FILENO, \"\\033[H\\033[2J\\033[3J\", 12);\n\treturn (0);\n\t//esegue clear \"\\033[H\" si muove a HOME , \"\\033[2J\" pulisce \n\t//l'area attuale \"\\033[3J\" pulisce anche la history\n}\n\nvoid print_env(char **env)\n{\n\tfor (int i = 0; env[i]; i++)\n\t\tprintf(\"%s \", env[i]);\n}\n\nvoid print_env_var(char **env, char *var)\n{\n\tfor (int i = 0; env[i]; i++)\n\t{\n\t\tif (!strncmp(env[i], var, strlen(var)))\n\t\t\tprintf(\"%s\\n\", env[i]);\n\t}\n}\n\nt_data\t*data_init(char **env)\n{\n\tt_data\t*data;\n\n\tdata = ft_calloc(1, sizeof(*data));\n\tif (!data)\n\t\treturn (NULL);\n\tdata->exit_status = new_var(\"?\", \"666\");\n\tif (!data->exit_status)\n\t{\n\t\tfree(data);\n\t\treturn (NULL);\n\t}\n\tupdate_exit_status(data->exit_status, 0);\n\tdata->export_var = get_env_list((const char **)env);\n\tif (!data->export_var)\n\t{\n\t\tfree(data->exit_status);\n\t\tfree(data);\n\t\treturn (NULL);\n\t}\n\treturn (data);\n}\n\nvoid\tupdate_exit_status(t_var *exit_status, int new_val)\n{\n\tint\tpow;\n\tint\ti;\n\n\tft_bzero(exit_status->value, sizeof(char) * 4);\n\tif (!new_val)\n\t{\n\t\texit_status->value[0] = '0';\n\t\treturn ;\n\t}\n\tpow = 1;\n\ti = 0;\n\twhile (pow * 10 < new_val)\n\t\tpow *= 10;\n\twhile (pow)\n\t{\n\t\texit_status->value[i] = new_val / pow % 10 + '0';\n\t\ti++;\n\t\tpow /= 10;\n\t}\n}\n\nvoid\tsignal_handler(int signo)\n{\n\tif (signo == SIGINT)\n\t{\n\t\twrite(1, \"\\n\", 1);\n\t\trl_replace_line(\"\", 1);\n\t\trl_on_new_line();\n\t\trl_redisplay();\n\t}\n}\n\nvoid\tfree_data(t_data *data)\n{\n\tif (!data)\n\t\treturn ;\n\tif (data->exit_status)\n\t\tfree_var(data->exit_status);\n\tif (data->export_var)\n\t\tft_lstclear(&data->export_var, free_var);\n\tfree(data);\n}\n\nvoid\tnull_list_test(t_data *data)\n{\n\tt_list *env = data->export_var;\n\n\twhile (env)\n\t{\n\t\tt_list *temp = env->next;\n\t\tft_unset((char *[]){\"env\", ((t_var *)env->content)->name, NULL}, data);\n\t\tenv = temp;\n\t}\n}\n\nchar \t*transform_for_dollar(char *s, t_data* data);\nt_pnode *create_command_list(char *s);\nint\trun_command_pipeline(t_pnode *pipeline_tree, t_data *data);\n\nint\tmain(int argc, char **argv, char **env)\n{\n\tchar\t*input;\n\tt_data\t*data;\n\n\tsignal(SIGQUIT, SIG_IGN);\n\tsignal(SIGINT, signal_handler);\n\tdata = data_init(env);\n\tif (!data)\n\t\treturn (1);\n\t(void)argc;\n\t(void)argv;\n\tclear(); //pulisce all'avvio\n\twhile (1)\n\t{\n        input = readline(\"Minishell> \"); //stampa e aspetta un input\n\t\tif (!input || !ft_strncmp(input, \"exit\", 5))\n\t\t{\n\t\t\twrite(1, \"exit\", 5);\n\t\t\tfree_data(data);\n\t\t\tif (input)\n\t\t\t\tfree(input);\n\t\t\texit (0);\n\t\t}\n\t\tadd_history(input); // aggiunge alla storia da solo! non serve la struct\n\t\t// char *temp = input;\n\t\tinput = transform_for_dollar(input, data);\n\t\t// free(temp);\n\t\tif (!input)\n\t\t{\n\t\t\twrite(2, \"Malloc error\\n\", 14);\n\t\t\tfree_data(data);\n\t\t\treturn (1);\n\t\t}\n\t\tt_pnode *command_list = create_command_list(input);\n\t\t// int i = 0;\n\t\t// while(command_list)\n\t\t// {\n\t\t// \twhile(command_list->args)\n\t\t// \t\tprintf(\"|%s|\\n\", command_list->args[i++]);\n\t\t// \tcommand_list = command_list->output;\n\t\t// }\n\t\tfree (input);\n\t\tint es = run_command_pipeline(command_list, data);\n\t\tupdate_exit_status(data->exit_status, es);\n\t}\n\tfree_data(data);\n\treturn (0);\n}\n"
        }
    ]
}